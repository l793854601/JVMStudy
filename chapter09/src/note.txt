堆、栈、方法区的交互关系：
Person person = new Person();
其中：
1.Person类在方法区中。
2.person变量在Java虚拟机栈的局部变量表中。
3.new Person()对象在堆中。
4.在person对象中，有个指针指向方法区中的Person类型数据，表明这个person对象是用方法区中的Person类创建出来的。（对应的面试题：1.一个Object对象占用几个字节？2.为什么Android推荐使用@IntDef而不是枚举）

方法区在哪里？
JVM规范中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾手机或者进行压缩。
但对于HotSpotJVM而言，方法去还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。
所以，方法区看做是一块独立于Jaa堆的内存空间。
上一章节中提到过：堆的组成包含：年轻代、老年代、永久代（元空间）。其中永久代（元空间）本质上不属于堆，它是方法区的具体实现。

方法区的基本理解：
1.方法区与Java堆一样，是各个线程共享的内存区域。
2.方法区在JVM启动的时候被创建，并且它的实际物理内存空间中和Java堆区一样，都是可以不连续的。
3.方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。
4.方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出：
java.lang.OutOfMemoryError: PermGen space（JDK7及以前，永久代OOM）
java.lang.OutOfMemoryError: Metaspace（JDK8及以后，元空间OOM）
5.关闭JVM就会释放这个区域的内存。（也就是说，方法区的生命周期与JVM一致）
























