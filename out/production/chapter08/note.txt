堆的核心概念：
1.一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
2.Java堆区在JVM祛痘的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间（堆内存的大小是可以调节的）。
3.JVM规范中规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
4.所有的线程共享Java堆，这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。
5.JVM虚拟机规范中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。从实际的角度看，“几乎”所有的对象实例都在堆中分配。
6.数组和对象可能永远不会存储在栈上，因为栈帧中保留引用，这个引用指向对象或者数组在堆中的位置。
7.在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收的时候才会被移除。（GC时会STW，停止用户线程，因此不能频繁的GC）
8.堆，是GC执行垃圾回收的重点区域。

现代垃圾收集器大部分都基于分带收集理论设计，堆空间分为：
Java7及之前堆内存逻辑上分为三部分：新生区、养老区、永久区
Java8及之后堆内存逻辑上分为三部分：新生区、养老区、元空间
新生区=Eden区+S0区+S1区
约定：
新生区=新生代=年轻代
养老区=老年区=老年代
永久区=永久代

堆空间从逻辑上分为三个部分：新生区、养老区、永久区（元空间）
实际上堆空间不包含永久区（元空间）
永久区（元空间）被看成是方法区的具体落地实现

堆空间大小的设置：
1.Java堆区用于存储Java对象实例，那么堆的大小启动时就已经设定好了，可以通过-Xms、-Xmx设置。
1）-Xms用于表示堆区的起始内存，等价于-XX:InitialHeapSize。
2）-Xmx用于表示堆区的最大内存，等价于-XX:MaxHeapSize。
2.一旦堆区的内存大小超过-Xmx所指定的最大内存时，黄慧抛出OutOfMemoryError。
3.通过-Xms、-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。
4.默认情况下，初始内存大小：物理电脑内存大小/64，最大内存大小：物理电脑内存大小/4。

年轻代和老年代：
存储在JVM中的Java对象可以被划分为两类：
1.生命周期较短的瞬时对象这类对象的创建和消亡都非常迅速
2.生命周期非常长，在某些极端的情况下还能够与JVM的生命周期保持一致
Java堆区进一步细分，可以划分为年轻代、老年代
其中年轻代又可以划分为Eden区、Survivor0区、Survivor1区（也称为from区、to区）

配置新生代与老年代在堆结构的占比：
默认：-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
可以修改：-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1//5
在HotSpot中，Eden区和另外两个空间缺省所占的比例为8:1:1，可以使用-XX:SurvivorRatio调整这个比例
几乎所有的Java对象都是在Eden区被new出来的
绝大部分的Java对象的销毁都是在新生代进行了（有些大的对象在Eden区无法存储的时候，将直接进入老年代）
IBM公司的专门研究表明：新生代中80%的对象都是"朝夕生死"的
可以使用-Xmn设置新生代最大内存大小，但这个参数一般使用默认值就可以了

对象分配过程：
1.new的对象先放到Eden区，此区有大小限制。
2.当Eden区空间填满时，程序又需要创建对象，JVM的垃圾回收器将会对Eden区进行垃圾回收（Minor GC），
将Eden区中的不再被其他对象所引用的对象进行销毁。再加载新的对象到Eden区。
3.然后将Eden区剩余对象移动到S0区。
4.如果再次触发垃圾回收，此时上次幸存下来的放到S0区，如果没有回收，就会放到S1区（from区，to区不断交换的，谁空谁是to）。
5.如果再次经历垃圾回收，此时会重新放到S0区，接着再去S1区（S0、S1区数据是复制交换的，为了解决碎片问题）。
6.啥时候去养老区？可以设置次数，默认为15次（年龄计数，GC时，对象回收不掉，这个数就+1）。
-XX:MaxTenuringThreshold=N
7.在养老区，相对休闲。当养老区内存不足时，再次触发GC（Major GC），进行养老区的内存清理。
8.如果养老区执行了Major GC之后，依然无法进行对象的保存，就会产生OOM
java.lang.OutOfMemoryError: Java heap space

总结：
1.针对S0、S1区的总结：复制之后有交换，谁空谁是to
2.关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集
3.from、to区：from区是接受从Eden区回收不掉的对象

注意：Eden区满会主动触发Minor GC，Survivor区满了不会触发Minor GC，但Minor GC触发时，也会清理Survivor区

特殊情况：
1.new的对象，先看看Eden区是否放得下：
1）如果Eden放得下，则直接放到Eden区。
2）如果Eden放不下，则触发Minor GC，执行GC之后，看看还能不能放得下？
2.将对象放到老年区又有两种情况：
1）如果Eden区执行了Minor GC还是放不下对象，那说明是超大对象，只能直接放到老年代
2）如果老年代也放不下，则先触发FullGC，再看看能不能放得下，如果还放不下，则报OOM
3.如果Eden区满了，将对象往Survivor区拷贝时，发现Survivor区放不下，那只能将它们直接放入老年区

Minor GC、Major GC、Full GC：
Minor GC等价于Young GC（YGC）

1.垃圾回收会STW（Stop the World，停止用户线程），而Major GC和Full GC出现STW的时间，是Minor GC的10倍以上。
2.JVM在进行GC时，并非每次都对上面三个内存区域（新生代、老年代、永久代/元空间）一起回收的，大部分时候回收的都是指新生代。
针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：1.部分收集（Partial GC）2.整堆收集（Full GC）
部分收集：不是完整收集整个Java堆的垃圾收集，其中又分为：
1）新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集
2）老年代收集（Major GC/Old GC）：只是老年代的收集
目前，只有CMS GC会有单独收集老年代的行为
注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收
混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集（目前只有G1 GC会有这种行为）
整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集

Minor GC触发机制：
1.当年轻代（Eden区）空间不足时，就会出发Minor GC，这里的年轻代满指的是Eden区满，Survivor区满不会引发GC（每次Minor GC会清理Eden、Survivor的内存）。
2.因为Java对象大部分都具备朝生夕灭的特性，所以Minor GC非常频繁，一般速度也比较快。
3.Minor GC会引发STW，暂停其他用户线程，等垃圾回收结束，用户线程才能恢复运行。

Major GC/Full GC触发机制：
1.指发生在老年代的GC，对象从老年代消失时，我们说Major GC或Full GC发生了。
2.出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接机型Major GC的策略）。
也就是在老年代空间不足时，会先此昂是出发Minor GC。如果之后空间还不足，则触发Major GC。
3.Major GC的速度一般比Minor GC慢10倍以上，STW的时间更长。
4.如果Major GC后，内存还不足，就报OOM了。

Full GC触发机制：
1.调用System.gc()时，系统建议执行Full GC但不是必然执行的。
2.老年代空间不足。
3.方法区空间不足。
4.通过Minor GC后进入老年代的平均大小大于老年代的可用内存。
5.由Eden区、Survivor space0（From Space）区向Survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象的大小

为什么需要把Java堆分代：
经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。
新生代：有Eden，两块大小相同的Survivor（又称from/to、S0/S1）构成，to总为空。
老年代：存放新生代中经历多次GC仍然存活的对象。

不分代可以吗：
其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那所有的对象都在一起。
GC的时候要找到哪些对象没用，这样就会对整堆区域进行扫描。
很多对象都是朝生夕灭的，如果分代的话，把新创建的对象放在某一地方（Eden区），当GC的时候会先把这块存储朝生夕灭的对象区域进行回收，这样就会腾出很大的空间出来，

内存分配策略：
1.如果对象在Eden区出生并经过第一次Minor GC后仍然存活，并且能被Survivor区容纳的话，江北移动到Survivor区中，并将对象年龄设为1。
2.对象在Survivor区中每熬过一次Minor GC，年龄就增加1。
3.当Survivor区中对象的年龄增加到一定程度（默认为15，其实每个JVM、每个GC都不同），就会晋升到老年代中。
对象晋升老年代的年龄阈值，可以通过选项 -XX:MaxTenuringThreshold来设置。

针对不同年龄段的对象分配原则如下：
1.优先分配到Eden区。
2.大对象（连续的内存空间）直接分配到老年代（Eden区经历Minor GC后仍无法放下的对象。尽量避免程序中出现过多的大对象）。
3.长期存活的对象（年龄计数达到阈值）最终会被分配到老年代。
4.动态对象年龄判断。
如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需到年龄阈值。
5.空间分配担保：
-XX:HandlePromotionFailure

为什么有TLAB（Thread Local Allocation Buffer）：
1.堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据。
2.由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。
3.为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

什么是TLAB：
1.从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它可以包含在Eden空间内。
2.多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，这种内存分配方式称为快速分配策略。
3.所有OpenJDK衍生出来的JVM都提供了TLAB的设计。

TLAB的再说明：
1.尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。
2.在程序中，开发人员可以通过选项-XX:UseTLAB设置是否开启TLAB。
3.默认情况下，TLAB空间的内存非常小，仅占整个Eden区的1%，可以使用-XX:TLABWasteTargetPercent设置TLAB空间所占Eden区的百分比。
4.一旦对象在TLAB空间分配内存失败，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。

堆空间常用的JVM参数：
1.-XX:+PrintFlagsInitial：查看所有的参数的默认初始值
2.-XX:+PrintFlagsFinal：查看所有的参数的最终值（有可能存在修改，不再是初始值）
具体查看某个参数的指令：jps：查看当前运行中的进程
                   jinfo -flag SurvivorRatio 进程id
3.-Xms：初始堆空间内存（默认为物理内存的1/64）
4.-Xmx：最大堆空间内存（默认为物理内存的1/4）
5.-Xmn：设置新生代的大小（初始值及最大值）
6.-XX:NewRatio：设置老年代与新生代在堆结构的占比
7.-XX:SurvivorRatio：设置新生代中Eden区与Survivor区的比例
8.-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄（年龄计数，默认为15）
9.-XX:+PrintGCDetails：输出详细的GC处理日志（只有当程序结束时才会输出）
10.-XX:+PrintGC：输出简要的GC信息
11.-XX:HandlePromotionFailure：是否设置空间分配担保

在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。
    如果大于，则此次Minor GC时安全的。
    如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败
        如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续连续空间历次晋升到老年代的对象的平均大小
            如果大于，则舱室进行一次Minor GC，但这次Minor GC依然是有风险的
            如果小于，则改为进行一次Full GC
        如果HandlePromotionFailure=false，则改为进行一次Full GC

JDK6 Update24（JDK7）之后，HandlePromotionFailure不会再影响到虚拟机的空间分配担保策略，规则变为：
只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC
相当于JDK7及以后，HandlePromotionFailure=true

堆是分配对象存储的唯一选择吗？
随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了。
在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。
但是，有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无需GC（对外存储技术）。
此外，基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，以此达到降低GC的回收频率和提升GC的回收效率的目的。

1.如何将堆上的对象分配到栈，需要使用逃逸分析手段。
2.这是一种可以有效减少Java程序中同步负载和内存分配压力的跨函数全局数据流分析算法。
3.通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用的适用范围从而决定是否要将这个对象分配到堆上。
4.逃逸分析的基本行为就是分析对象动态作用域：
1）当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
2）当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为方法的入参或返回结果。
没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。
在JDK 6u23（JDK7），HotSpot中默认就已经开启了逃逸分析。

结论：
开发中能使用局部变量的，就不要使用在方法外定义（成员变量、入参、方法返回值 ）。

使用逃逸分析，编译器可以对代码做如下优化：
1.栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。
2.同步省略。如果一个对象被发现只能从一个线程访问到，那么对于这个对象的操作可以不考虑同步。
3.分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中（Java是存储在栈中）。




























