堆的核心概念：
1.一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
2.Java堆区在JVM祛痘的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间（堆内存的大小是可以调节的）。
3.JVM规范中规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
4.所有的线程共享Java堆，这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。
5.JVM虚拟机规范中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。从实际的角度看，“几乎”所有的对象实例都在堆中分配。
6.数组和对象可能永远不会存储在栈上，因为栈帧中保留引用，这个引用指向对象或者数组在堆中的位置。
7.在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收的时候才会被移除。（GC时会STW，停止用户线程，因此不能频繁的GC）
8.堆，是GC执行垃圾回收的重点区域。

现代垃圾收集器大部分都基于分带收集理论设计，堆空间分为：
Java7及之前堆内存逻辑上分为三部分：新生区、养老区、永久区
Java8及之后堆内存逻辑上分为三部分：新生区、养老区、元空间
新生区=Eden区+S0区+S1区
约定：
新生区=新生代=年轻代
养老区=老年区=老年代
永久区=永久代

堆空间从逻辑上分为三个部分：新生区、养老区、永久区（元空间）
实际上堆空间不包含永久区（元空间）
永久区（元空间）被看成是方法区的具体落地实现

堆空间大小的设置：
1.Java堆区用于存储Java对象实例，那么堆的大小启动时就已经设定好了，可以通过-Xms、-Xmx设置。
1）-Xms用于表示堆区的起始内存，等价于-XX:InitialHeapSize。
2）-Xmx用于表示堆区的最大内存，等价于-XX:MaxHeapSize。
2.一旦堆区的内存大小超过-Xmx所指定的最大内存时，黄慧抛出OutOfMemoryError。
3.通过-Xms、-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。
4.默认情况下，初始内存大小：物理电脑内存大小/64，最大内存大小：物理电脑内存大小/4。























