大厂面试题：
美团：
对象在JVM是怎么存储的？
对象头信息里面有哪些东西？

蚂蚁金服：
二面：Java对象头里有什么？

对象的实例化：
创建对象的方式：
1.new：最常见的方式、单例类中调用getInstance、XXXFactory的静态方法
2.Class的newInstance()：反射的方式。在JDK9中过时，因为只能调用无参构造器、且这个构造器必须为public
3.Constructor的newInstance(Xxx)：以反射的方式，调用无参或有参构造器
4.使用clone()：不调用任何构造器，要求类实现Clonable接口并实现clone()方法
5.使用反序列化：Serializable、安卓端的Parcelable
6.第三方库Objensis：字节码技术

创建对象的步骤：
1.判断对象对应的类是否加载、链接、初始化
虚拟机遇到一条new指令，首先区检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析、初始化（类元信息是否存在）。
如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。
如果没有找到文件，则抛出ClassNotFoundException异常。
如果找到，则进行类加载（加载、链接、初始化），并生成对应的Class类对象。

2.为对象分配内存
首先计算对象占用空间大小，接着在堆中划分一块内存给对象。
如果实例成员变量是引用类型变量，仅分配引用变量空间即可，即4个字节大小。

如果内存规整-指针碰撞：
如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。
意思就是所有用过的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。
如果垃圾收集器选择的是Serial、ParNew这种基于压缩善法的，虚拟机采用这种分配方式。
一般使用带有Compact（整理）过程的收集器时，使用指针碰撞。

如果内存不规整-空闲列表分配：
如果内存是不规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。
意思是虚拟机维护了一个列表，记录上那些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式叫做空闲列表（Free List）。

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

3.处理并发安全问题
采用CAS配上失败重试保证更新的原子性
每个线程预先分配一块TLAB（在Eden区为每一个线程分配一块区域）

4.初始化分配到的空间
所有属性设置默认值（零值），保证对象实例字段在不赋值时也可以直接使用

给对象的属性赋值的操作：
1）属性的默认初始化（零值）
2）显示初始化/代码块初始化（并列关系，谁先谁后看代码编写顺序，可对比clinit的执行过程）
3）构造器初始化

5.设置对象的对象头
将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。
这个过程的具体设置方式取决与JVM实现。

6.执行init方法进行初始化
在Java程序的视角来看，初始化才正式开始。
初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。
因此一般来说（由字节码中是否跟随着由invokespecial指令所决定），new指令之后接着就是执行方法，把对象按照程序员的意愿进行初始化。
这样一个真正可用的对象才算完全创建出来。

对象内存布局：
对象头（Header）：
1）运行时元数据（哈希值、CG分代年龄、锁状态标志、现存持有的锁、偏向线程ID、偏向时间戳）
2）类型指针（指向元数据InstanceKlass，确定该对象所属的类型）
说明：如果是数组，还需记录数组的长度

实例数据（Instance Data）：
说明：它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的合本身拥有的字段）
规则：
1）相同宽度的字段总是被分配到一起
2）父类中定义的变量会出现在子类之前
3）如果CompactFields参数为true（默认为true），子类的窄变量可能插入到父类变量的空隙

对齐填补（Padding）：
不是必须的，也没有特别含义，仅仅起到占位符的作用

JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？
栈帧（reference存储着堆中对象的地址值）->堆区（InstanceOopDesc，对象头中存着元数据指针，指向方法区的类元信息）->方法区（InstanceKlass）

对象访问方式主要有两种：
1.句柄访问（中间层）
优点：reference中存储稳定句柄地址，对象被移动（垃圾收集器时对象移动很普遍）时，只会改变句柄中实例数据指针即可，reference本身不需要被修改。
缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间。通过两次指针访问才能访问到堆中的对象，效率低。
2.直接指针（HotSpot采用）
优点：直接指针式局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据（相比于句柄访问更直接）
缺点：对象被移动时，需要修改reference的值















